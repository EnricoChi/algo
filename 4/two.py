# Задача 2.
#
# Вам пришел ежемесячный счет за телефон, он кажется слишком большим.
# Вы решаете проверить его самостоятельно на основе телефонных логов и доступной информации о тарифах вашего оператора.
#
# Логи представлены в виде строки S, состоящей из N строк, разделенной символом окончания строки (EOL, ASCII код -- 10).
# Каждая строка описывает телефонный звонок, используя следующий формат "hh:mm:ss, nnn-nnn-nnn", где "hh:mm:ss"
# обознают длительность звонка (в "hh" часы, "mm" -- минуты, "ss" -- секунды), а "nnn-nnn-nnn" обозначают телефонный
# номер из 9 цифр, на который производился звонок (без ведущих нулей).
#
# За каждый звонок плата взимается отдельно. Правила тарифа следующие:
#
#     Если звонок был короче 5 минут, то вы платите по 3 цента за каждую начавшуюся секунду звонка
#     (например, за длительность "00:01:07" вы заплатите 67 * 3 = 201 цент).

#     Если звонок длился не менее 5 минут, то вы платите 150 центов за каждую начавшуюся минуту звонка
#     (например, за длительность "00:05:00" вы платите 5 * 150 = 750 центов,
#     а за длительность "00:05:01" вы платите 6 * 150 = 900 центов).

#     Все звонки на телефон, чья общая продолжительность звонков оказалось самой большой за месяц, бесплатны.
#     В случае коллизии, когда несколько номеров имеют одинаковую и самую большую общую длину звонков,
#     скидка применяется к тому номеру, у которого сумма цифр номера самая маленькая.
#


# Напишите функцию:
# def check_phone_bill(S):
# которая получает на вход строку S,
# содержащую лог телефонных звонков, и возвращает количество денег в центах, которое вы должны заплатить.
#
# Например, дана строка S с N = 3 строк:
#
# "00:01:07,400-234-090
# 00:05:01,701-080-080
# 00:05:00,400-234-090"
#
# Функция должна вернуть 900 (общая длина звонков для номера 400-234-090 -- 6 минут 7 секунд, а общая длина звонков на
# номер 701-080-080 -- 5 минут 1 секунда, следовательно, скидка применяется для первого телефонного номера).
#
# Преполагайте, что:
# * N -- целое число в интервале [0..100];
# * каждый телефонный номер строго соответствует формату "nnn-nnn-nnn", ведущие нули отсутствуют;
# * длительность телефонных звонков строго соответствует формату "hh:mm:ss" (00 <= hh <= 99, 00 <= mm, ss <= 59);
# * каждая строка лога строго соответствует формату "hh:mm:ss,nnn-nnn-nnn", в логе нет пустых строк и пробелов.

lst = []


def check_phone_bill(S):
    # Граница 5 минут в секундах
    BORDER = 5 * 60
    result_dict = {}
    time_dict = {}
    total_bill = 0
    # Переберём каждое N в S
    for log in S:
        # Каждая строка в кортеж с удалением переноса строки
        row = tuple(log.strip().split(','))

        # Посчитаем общее время каждого разговора в секундах
        time = [int(i) for i in row[0].split(':')]
        sec_time = (time[0] * 3600) + (time[1] * 60) + time[2]
        # Будем делать отдельный словарь для времени звонков - костыль №1
        time_dict.setdefault(row[1], []).append(sec_time)

        # Если короче 5 минут (300 секунд)
        if sec_time < BORDER:
            # Считаем по секундам
            bill = sec_time * 3
        else:
            # проверим, ровное ли число минут
            if not sec_time % 60:
                bill = (sec_time // 60) * 150
            else:
                # добавим превышение, как 1 минуту сверху
                bill = ((sec_time // 60) + 1) * 150
        # запихнём всё в словарь {телефон: [стоимость звонка 1, стоимость звонка 2]}
        result_dict.setdefault(row[1], []).append(bill)

    # Будем искать самое длинное время звонков
    if time_dict:
        # Костыль №2, сам не понимаю что тут происходит
        t = {phone: sum(time) for phone, time in time_dict.items()}
        v_time = list(t.values())
        k_time = list(t.keys())
        # Нашли ключ от максимального времени
        max_time_phone = k_time[v_time.index(max(v_time))]

        if result_dict:
            # Удаляем его из словаря
            del result_dict[max_time_phone]

        # Складываем стоимость внутри каждого номера
        result_dict = {phone: sum(bill) for phone, bill in result_dict.items()}

        # Складываем стоимость, всех звонков
        for i in result_dict.values():
            total_bill += i
        return total_bill
    return None


with open('log.txt', 'r', encoding='ascii') as S:
    print(check_phone_bill(S))

